import ij.IJ;import java.util.*;public class CodeClass {	/**	* Perform a wavelet transform.	*/	static public ImageAccess analysis(ImageAccess image, int n) {			// Compute the size to the fine and coarse levels		int nx = image.getWidth();		int ny = image.getHeight();				// Declare the object image		ImageAccess sub;		ImageAccess output = image.duplicate();		// From fine to coarse main loop		for (int i=0; i<n; i++) {					// Create a new image array of size [nx,ny]			sub = new ImageAccess(nx, ny);						// Copy in into image			output.getSubImage(0, 0, sub);						// Apply the Wavelet splitting			sub = split(sub);						// Put the result image into in			output.putSubImage(0, 0, sub);						// Reduce the size by a factor of 2			nx = nx / 2;			ny = ny / 2;		}		return output;	}	/**	* Perform 1 iteration of the wavelet transform.	*/	static private ImageAccess split(ImageAccess in) {		int nx = in.getWidth();		int ny = in.getHeight();		ImageAccess out = new ImageAccess(nx, ny);		double rowin[]  = new double[nx];		double rowout[] = new double[nx];		for (int y=0; y<ny; y++) {			in.getRow(y, rowin);			split_1D(rowin, rowout);			out.putRow(y,rowout);		}				double colin[] = new double[ny];		double colout[] = new double[ny];		for (int x=0; x<nx; x++) {			out.getColumn(x, colin);			split_1D(colin, colout);			out.putColumn(x,colout);		}		return out;	}	/**	* Perform 1 iteration of the wavelet transformation.	*/	static private void split_1D(double vin[], double vout[]) {		double sqrt2 = Math.sqrt(2.0);		        // Add your code here                int mid = vin.length / 2;        for (int k=0; k<mid; k++) {            vout[k] = ((vin[2 * k] + vin[(2 * k + 1)]) / sqrt2);            vout[(k + mid)] = ((vin[2 * k] - vin[(2 * k + 1)]) / sqrt2);        }	}	/**	* Perform an inverse wavelet transform.	*/	static public ImageAccess synthesis(ImageAccess image, int n) {	    		int i = (int)Math.pow(2.0, n - 1);        int j = image.getWidth() / i;        int k = image.getHeight() / i;              ImageAccess output = image.duplicate(); // To be replaced                int x = j;        int y = k;                for (int index=0; index<n; index++) {            ImageAccess tempImage = new ImageAccess(x, y);            output.getSubImage(0, 0, tempImage);            tempImage = merge(tempImage);            output.putSubImage(0, 0, tempImage);                        x *= 2;            y *= 2;        }                return output;			}	/**	* Perform 1 iteration of the inverse wavelet transform.	*/	static private ImageAccess merge(ImageAccess in) {		//ImageAccess out = in.duplicate(); // To be replaced		        int i = in.getWidth();        int j = in.getHeight();        ImageAccess out = new ImageAccess(i, j);                //since split() order was row then column, the reverse will be applied to merge()                double[] colIn = new double[j];        double[] colOut = new double[j];                for (int k=0; k<i; k++) {            in.getColumn(k, colIn);            merge_1D(colIn, colOut);            out.putColumn(k, colOut);        }                double[] rowIn = new double[i];        double[] rowOut = new double[i];                for (int r = 0; r < j; r++) {            out.getRow(r, rowIn);            merge_1D(rowIn, rowOut);            out.putRow(r, rowOut);        }                  return out;	}	/**	* Performs 1 iteration of the inverse wavelet transform.	*/	static private void merge_1D(double vin[], double vout[]) {        		int i = vin.length / 2;        double sqrt2 = Math.sqrt(2.0);                for (int k = 0; k < i; k++) {            vout[(2 * k)] = ((vin[k] + vin[(k + i)]) / sqrt2);            vout[(2 * k + 1)] = ((vin[k] - vin[(k + i)]) / sqrt2);        }	}	/**	* Keep only specified subband.	*/	static public ImageAccess keepHighpassSubBand(ImageAccess coef, int n) {        		int nx = coef.getWidth();		int ny = coef.getHeight();		ImageAccess output = new ImageAccess(nx, ny);				return output;	}	/**	* Keep only specified subband.	*/	static public ImageAccess keepLowpassSubBand(ImageAccess coef, int n) {		int nx = coef.getWidth();		int ny = coef.getHeight();		ImageAccess output = new ImageAccess(nx, ny);		// Add your code here		return output;	}	/**	* Detect sharp areas.	*/	static public void detectSharpArea(ImageAccess input, int n, double threshold) {		int nx = input.getWidth();		int ny = input.getHeight();		ImageAccess mask = new ImageAccess(nx, ny);				mask.putPixel(1, 1, 1);	 // To be removed		mask.show("mask");		// Add your code here				Detect_SharpArea.showMaskOverlay(input, mask);	}}