import java.awt.*;import java.awt.event.*;import ij.*;import ij.gui.*;import ij.plugin.filter.PlugInFilter;import ij.process.*;/** * Image Transform Session.  *			 * @author 	Swiss Federal Institute of Technology Lausanne *			Biomedical Imaging Group *			Daniel Sage */public class ImageTransform_ extends Dialog implements ActionListener, ItemListener, WindowListener{	/**	* Constructor.	*/	public ImageTransform_() {		super(new Frame(), "Image Transformation");				if (IJ.versionLessThan("1.21a"))			return;		doDialog();	}	/**	* Run.	*/	private void run() {			// Get and check the image			ImagePlus impSource = WindowManager.getCurrentImage();			 	if (checkImage(impSource) == false)	 		return;				// Get the parameters		int transform = choiceTransform.getSelectedIndex();		int processing = choiceProcessing.getSelectedIndex();		int scale = (new Integer(choiceScale.getSelectedItem()).intValue());		boolean flagScaledValues = choiceOutput.getSelectedItem().equals("Scaled Values");		int nx = impSource.getWidth();		int ny = impSource.getHeight();		if (nx / Math.pow(2, scale) < 1.0) {			IJ.write("Too many scales.");			return;		}				// Processing		ImageAccess original = new ImageAccess(impSource.getProcessor());		ImageAccess coef = null;		double startTime=0;				// Direct Transform		if (chkTransform.getState() == true) {			IJ.showStatus("Analysis: " + choiceTransform.getSelectedItem());			startTime = System.currentTimeMillis();			switch(transform) {				case 0: // Haar Session					coef = CodeClass.analysis(original, scale);					break;				case 1: // Haar Solution					coef = TeacherCode.analysis(original, scale);					break;				case 2: // DCT					coef = DCTBlock.analysis(original, 8);					break;				case 3: // Spline 3					coef = WaveSpline.analysis(original, scale);					break;			}		}		else {			coef = original.duplicate();		}				// Processing		ImageAccess output = coef.duplicate();			if (chkProcess.getState() == true) {			IJ.showStatus("Process" + choiceProcessing.getSelectedItem());			if (processing == 0) {				double value = getDoubleValue(txtThreshold, 0.0, 0.0, Double.MAX_VALUE);				output = TeacherCode.thresholdHard(coef, scale, value);			}			else if (processing == 1) {				output = CodeClass.keepHighpassSubBand(coef, scale);			}			else if (processing == 2) {				output = CodeClass.keepLowpassSubBand(coef, scale);			}		}				// Rescale coefficients		if (flagScaledValues == true) {			if (transform == 2) {					output.add(127.5);			}			else {				CoefSolution.rescale(output, scale);			}		}				// Inverse transform		ImageAccess reconst = output.duplicate();			if (chkInverse.getState() == true) {			IJ.showStatus("Synthesis: " + choiceTransform.getSelectedItem());			switch(transform) {				case 0: // Haar Session					reconst = CodeClass.synthesis(output, scale);					break;				case 1: // Haar Solution					reconst = TeacherCode.synthesis(output, scale);					break;				case 2: // DCT					reconst = DCTBlock.synthesis(output, 8);					break;				case 3: // Spline 3					reconst = WaveSpline.synthesis(output, scale);					break;			}		}				// Display of the result				switch(transform) {			case 0: // Haar Student				reconst.show("Haar Student (" + scale + ") of " + impSource.getTitle());				break;			case 1: // Haar Teacher				reconst.show("Haar Teacher (" + scale + ") of " + impSource.getTitle());				break;			case 2: // DCT				reconst.show("DCT of " + impSource.getTitle());				break;			case 3: // Spline 3				reconst.show("Spline Wavelet (" + scale + ") of " + impSource.getTitle());				break;		}	}	/**	* Check the size image.	*/	private boolean checkImage(ImagePlus imp) {		if (imp == null) {			IJ.error("No images are opened.");			return false;		}				int nx = imp.getWidth();		int ny = imp.getHeight();				if (nx <= 2) {			IJ.error("The input image should greater than 2.");			return false;		}		if (ny <= 2) {			IJ.error("The input image should greater than 2.");			return false;		}				if (nx != ny) {			IJ.error("The input image should be square.");			return false;		}		int i=2;		while (i < nx) 			i *= 2;				if (i != nx) {			IJ.error("The size of the image should be a power of 2.");			return false;		}				return true;	}	/**	* Build the dialog box.	*/	private GridBagLayout 		layout			= new GridBagLayout();	private GridBagConstraints 	constraint		= new GridBagConstraints();	private Checkbox 			chkTransform;	private Checkbox 			chkProcess;	private Checkbox 			chkInverse;	private Choice 				choiceScale;	private Choice 				choiceProcessing;	private Choice 				choiceTransform;	private Button 				bnClose;	private Button 				bnRun;	private TextField			txtThreshold;	private Label				lblThreshold	= new Label("Rate of non-zero coef");	private Choice 				choiceOutput;	private TextField			txtFactor;	private Label				lblScale;	private Label				lblOutput;	private TextField			txtStart;	private TextField			txtEnd;	private TextField			txtStep;	private Panel				pnThreshold;	private	Panel				pnScale = new Panel();					private void doDialog() {				// Check action		chkTransform = new Checkbox("Transform",true);		chkProcess = new Checkbox("Processing",false);		chkInverse = new Checkbox("Inverse transform",false);				// List of wavelets		choiceTransform  = new Choice();		choiceTransform.add("Haar Student Version");		choiceTransform.add("Haar Teacher Version");		choiceTransform.add("DCT");		choiceTransform.add("Spline Wavelets");		choiceTransform.select(0);				// Scale		lblScale = new Label("Number of scale", Label.RIGHT);		choiceScale = new Choice();		choiceScale.add("1"); 		choiceScale.add("2"); 		choiceScale.add("3"); 		choiceScale.add("4"); 		choiceScale.add("5"); 		choiceScale.add("6"); 		choiceScale.add("7"); 		choiceScale.add("8"); 		choiceScale.select(2);		pnScale.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 0));		pnScale.add(lblScale);		pnScale.add(choiceScale);		// Choice Processing		choiceProcessing = new Choice();		choiceProcessing.add("Hard Threshold");		choiceProcessing.add("Keep 3 Highpass Sub-Band");		choiceProcessing.add("Keep 1 Lowpass Sub-Band");		choiceProcessing.select(0);		choiceProcessing.disable();		// Choice output		lblOutput = new Label("Output", Label.RIGHT);		choiceOutput = new Choice();		choiceOutput.add("Scaled Values");		choiceOutput.add("True Values");		choiceOutput.select(1);		// Buttons		bnClose = new Button("Close");		bnRun   = new Button(" Run ");				// Panel Threshold 		pnThreshold = new Panel();	 	txtThreshold = new TextField("2", 10);		pnThreshold.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 0));		pnThreshold.add(lblThreshold);		pnThreshold.add(txtThreshold);		// Panel buttons 		Panel pnButtons = new Panel();		pnButtons.setLayout(new FlowLayout(FlowLayout.RIGHT, 8, 0));		pnButtons.add(bnClose);		pnButtons.add(bnRun);	 			// Panel parameters			Panel pnParameters = new Panel();		pnParameters.setLayout(layout);	 	addComponent(pnParameters, 0, 0, 1, 1, 5, chkTransform);	 	addComponent(pnParameters, 0, 1, 1, 1, 5, choiceTransform);	 	addComponent(pnParameters, 1, 1, 1, 1, 5, pnScale);	 		 	addComponent(pnParameters, 2, 0, 1, 1, 5, chkProcess);	 	addComponent(pnParameters, 2, 1, 1, 1, 5, choiceProcessing);		addComponent(pnParameters, 4, 1, 1, 1, 5, pnThreshold);		addComponent(pnParameters, 5, 0, 1, 1, 5, chkInverse);				addComponent(pnParameters, 6, 0, 1, 1, 5, lblOutput);			addComponent(pnParameters, 6, 1, 1, 1, 5, choiceOutput);			addComponent(pnParameters, 7, 1, 1, 1, 8, pnButtons);						// Add Listeners		bnClose.addActionListener(this);		bnRun.addActionListener(this);		choiceTransform.addItemListener(this);		chkTransform.addItemListener(this);		chkProcess.addItemListener(this);		chkInverse.addItemListener(this);		choiceProcessing.addItemListener(this);				addWindowListener(this);				// Building the main panel		add(pnParameters);		pack();		setResizable(false);		GUI.center(this);		setVisible(true);		IJ.wait(250); 	// work around for Sun/WinNT bug		enableComponents();	}	/**	* Add a component in a panel in the northeast of the cell.	*/	final private void addComponent(Panel pn, int row, int col, int width, int height, int space, Component comp) {	    constraint.gridx = col;	    constraint.gridy = row;	    constraint.gridwidth = width;	    constraint.gridheight = height;	    constraint.anchor = GridBagConstraints.NORTHWEST;	    constraint.insets = new Insets(space, space, space, space);		constraint.weightx = IJ.isMacintosh()?90:100;		constraint.fill = constraint.HORIZONTAL;	    layout.setConstraints(comp, constraint);	    pn.add(comp);	}	/**	* Implements the actionPerformed for the ActionListener.	*/	public synchronized  void actionPerformed(ActionEvent e) {		if (e.getSource() == bnClose) {			dispose();		}				if (e.getSource() == bnRun) {			run();		}		notify();	}			/**	* Implements the itemStateChanged for the ItemListener.	*/	public synchronized void itemStateChanged(ItemEvent e) {		enableComponents();	}	/**	* Implements the WindowEvent for the WindowListener.	*/	public synchronized void windowClosed(WindowEvent event) {}	public synchronized void windowDeiconified(WindowEvent event) {}	public synchronized void windowClosing(WindowEvent event) { dispose(); }	public synchronized void windowDeactivated(WindowEvent event) {}	public synchronized void windowIconified(WindowEvent event) {}	public synchronized void windowOpened(WindowEvent event) {}	public synchronized void windowActivated(WindowEvent event) {}	/**	*/	private void enableComponents() {		if (chkTransform.getState() == false &&  chkProcess.getState() == false && chkInverse.getState() == false) {			bnRun.disable();		}		else {			bnRun.enable();		}				if (chkInverse.getState() == true) {			choiceOutput.hide();			lblOutput.hide();			choiceOutput.select(1);		}		else {			choiceOutput.show();			lblOutput.show();		}				pnScale.setVisible(choiceTransform.getSelectedIndex() != 2);				if (chkProcess.getState() == true) {			choiceProcessing.show();			pnThreshold.show();			choiceProcessing.enable();			int processing = choiceProcessing.getSelectedIndex();			if (processing == 0) {				lblThreshold.show();				txtThreshold.show();			}			else {				lblThreshold.hide();				txtThreshold.hide();			}		}		else {			choiceProcessing.hide();			pnThreshold.hide();		}	}	/**	* Get a double value from a TextField between minimal and maximal values.	*/	private double getDoubleValue(TextField text, double mini, double defaut, double maxi)	{		double d;		try {			String s = text.getText();			if (s.charAt(0) == '-') { 				s = s.substring(1);			}				d = (new Double(s)).doubleValue();			if (d < mini)  				text.setText( "" + mini);			if (d > maxi)  				text.setText( "" + maxi);		}				catch (Exception e) {			if (e instanceof NumberFormatException) 				text.setText( "" + defaut);		}		d = (new Double(text.getText())).doubleValue();		return d;	}}